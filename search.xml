<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>部署Django项目</title>
      <link href="/2018/12/14/Django/Django/"/>
      <url>/2018/12/14/Django/Django/</url>
      
        <content type="html"><![CDATA[<h3 id="安装MariaDB"><a href="#安装MariaDB" class="headerlink" title="安装MariaDB"></a>安装MariaDB</h3><p>安装命令</p><pre><code>yum -y install mariadb mariadb-server</code></pre><p>安装完成MariaDB，首先启动MariaDB</p><pre><code>systemctl start mariadb</code></pre><p>设置开机启动</p><pre><code>systemctl enable mariadb</code></pre><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>命令: mysql_secure_installation</p><pre><code class="python">Enter current password for root:&lt;–初次运行直接回车设置密码Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车New password: &lt;– 设置root用户的密码Re-enter new password: &lt;– 再输入一次你设置的密码其他配置Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,回车,Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车初始化MariaDB完成，接下来测试登录mysql -u root -p</code></pre><h3 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h3><p>在mysql数据库中的user表中可以看到默认是只能本地连接的，所有可以添加一个新的用户，该用户可以远程访问</p><h4 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1. 创建用户"></a>1. 创建用户</h4><pre><code class="python"># 先使用数据库use mysql;# 针对ipcreate user &#39;root&#39;@&#39;192.168.10.10&#39; identified by &#39;password&#39;;#全部 create user &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39;;</code></pre><h4 id="2-授权"><a href="#2-授权" class="headerlink" title="2. 授权"></a>2. 授权</h4><pre><code class="python"># 给用户最大权限grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39;;# 给部分权限(test 数据库)grant all privileges on test.* to &#39;root&#39;@&#39;%&#39; identified by &#39;password&#39; with grant option;# 刷新权限表</code></pre><pre><code> flush privileges;# 查看show grants for &#39;root&#39;@&#39;localhost&#39;;</code></pre><p>接下来就可以在远程的数据库可视化工具中直接访问该服务器中的mysql了。</p><pre><code># 访问数据库mysql -u root -p</code></pre><h3 id="安装python3-6"><a href="#安装python3-6" class="headerlink" title="安装python3.6"></a>安装python3.6</h3><p>在centos中，系统默认只提供python2.7的版本，但是项目我们使用的python3.6的版本。所有我们自己安装python3</p><h4 id="安装Python3的方法"><a href="#安装Python3的方法" class="headerlink" title="安装Python3的方法"></a>安装Python3的方法</h4><p>首先安装依赖包</p><p>安装Python3.6所需要的依赖包：</p><pre><code>yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</code></pre><p>安装Python3.7还需额外安装依赖包：</p><pre><code>yum install libffi-devel -y</code></pre><p>然后根据自己需求下载不同版本的Python3，我下载的是Python3.6.2</p><pre><code class="python">wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tar.xz然后解压压缩包，进入该目录，安装Python3tar -xvJf  Python-3.6.2.tar.xzcd Python-3.6.2./configure --prefix=/usr/local/python3make &amp;&amp; make install</code></pre><p>最后创建软链接</p><pre><code>ln -s /usr/local/python3/bin/python3 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</code></pre><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><h4 id="1-安装virtualenv"><a href="#1-安装virtualenv" class="headerlink" title="1. 安装virtualenv"></a>1. 安装virtualenv</h4><pre><code>yum install python-virtualenv</code></pre><h4 id="2-创建虚拟环境"><a href="#2-创建虚拟环境" class="headerlink" title="2. 创建虚拟环境"></a>2. 创建虚拟环境</h4><pre><code>virtualenv --no-site-packages envcd env# 激活虚拟环境source bin/activate</code></pre><h4 id="3-安装环境需要的包"><a href="#3-安装环境需要的包" class="headerlink" title="3. 安装环境需要的包"></a>3. 安装环境需要的包</h4><pre><code>pip3 install -r re_install.txt其中re_install.txt文件中记录的是需要安装包的名称以及对应的版本</code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>该部署采用的是cenots7系统来部署</p><p>Django的项目中，在工程目录下settings.py文件中有一个DEBUG=True参数，如果DEBUG=False则会出现js,css，img无法加载的情况出现。</p><p>原因如下：</p><p>Django框架仅在开发模式下提供静态文件服务。当我开启DEBUG模式时，Django内置的服务器是提供静态文件的服务的，所以css等文件访问都没有问题，但是关闭DEBUG模式后，Django便不提供静态文件服务了。想一想这是符合Django的哲学的：这部分事情标准服务器都很擅长，就让服务器去做吧！</p><h4 id="1-测试环境中部署方式"><a href="#1-测试环境中部署方式" class="headerlink" title="1. 测试环境中部署方式"></a>1. 测试环境中部署方式</h4><h5 id="urls-py中的修改"><a href="#urls-py中的修改" class="headerlink" title="urls.py中的修改"></a>urls.py中的修改</h5><p>在测试环境中一般都直接使用python manage.py runserver的方式去运行项目。其中就涉及到DEBUG=False的修改，静态目录的修改等，具体修改如下：</p><pre><code class="python">a) 修改settings.py配置文件中的DEBUG=False模式，修改ALLOEWD_HOST=[&#39;*&#39;]b) 修改工程目录下的urls.pyfrom django.views.static import serveurlpatterns = [    url(r&#39;^admin/&#39;, admin.site.urls),    url(r&#39;^axf/&#39;, include(&#39;axf.urls&#39;, namespace=&#39;axf&#39;)),    # 增加以下的url路由    url(r&#39;^static/(?P&lt;path&gt;.*)$&#39;, serve, {&quot;document_root&quot;: settings.STATICFILES_DIRS[0]}),    url(r&#39;^media/(?P&lt;path&gt;.*)$&#39;, serve, {&quot;document_root&quot;: settings.MEDIA_ROOT}),</code></pre><pre><code>    url(r&#39;^$&#39;, views.home)]</code></pre><h5 id="中间件的修改"><a href="#中间件的修改" class="headerlink" title="中间件的修改"></a>中间件的修改</h5><p>如果中间件是过滤哪些地址不需要登录验证的话，可以设置如下的static和media过滤地址的参数：</p><pre><code class="python"># 验证用户的登录状态paths = [&#39;/user/login/&#39;, &#39;/user/register/&#39;,         &#39;/axf/market/&#39;, &#39;/axf/marketparams/(\d+)/(\d+)/(\d+)/&#39;,        &#39;/static/[0-9a-zA-Z/\.]&#39;, &#39;/media/[0-9a-zA-Z/\.]&#39;]for path in paths:    if re.match(path, request.path):        return None</code></pre><h4 id="2-正式环境中部署方式"><a href="#2-正式环境中部署方式" class="headerlink" title="2. 正式环境中部署方式"></a>2. 正式环境中部署方式</h4><p>正式环境中部署为nginx+uwsgi来部署django项目</p><h5 id="2-1-安装nginx"><a href="#2-1-安装nginx" class="headerlink" title="2.1 安装nginx"></a>2.1 安装nginx</h5><p>a）添加nginx存储库<br>​<br>​    yum install epel-release</p><p>b) 安装nginx</p><pre><code>yum install nginx</code></pre><p>c) 运行nginx</p><p>Nginx不会自行启动。要运行Nginx<br>​<br>​    systemctl start nginx</p><p>nginx的运行命令：</p><pre><code class="python"> systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动</code></pre><p>d）系统启动时启用Nginx<br>​<br>​    systemctl enable nginx</p><p>e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信：<br>​    </p><pre><code class="python">sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload</code></pre><h4 id="3-配置uwsgi"><a href="#3-配置uwsgi" class="headerlink" title="3.配置uwsgi"></a>3.配置uwsgi</h4><h5 id="3-1-安装uwsgi"><a href="#3-1-安装uwsgi" class="headerlink" title="3.1 安装uwsgi"></a>3.1 安装uwsgi</h5><p>在虚拟环境中安装uwsgi，假设虚拟环境安装在/home/env/axfenv中</p><pre><code>/home/env/axfeng/bin/python3/pip3 install uwsgi</code></pre><h4 id="4-配置项目代码，配置项目nginx，配置uwsgi-ini等"><a href="#4-配置项目代码，配置项目nginx，配置uwsgi-ini等" class="headerlink" title="4. 配置项目代码，配置项目nginx，配置uwsgi.ini等"></a>4. 配置项目代码，配置项目nginx，配置uwsgi.ini等</h4><p><strong>在home文件中创建如下四个文件夹</strong></p><p>conf是配置文件，用于存放项目的nginx.conf文件，uwsgi.ini文件</p><p>logs是日志文件，用于存放nginx的启动成功和失败文件，以及uwsgi的运行日志文件</p><p>env是用于存放虚拟环境</p><p>src是项目文件，该目录下上传的是目录代码</p><h4 id="4-1-配置nginx-conf文件"><a href="#4-1-配置nginx-conf文件" class="headerlink" title="4.1 配置nginx.conf文件"></a>4.1 配置nginx.conf文件</h4><p><b>首先</b>：编写自己项目的nginx.conf文件如下：</p><p>每一个项目对应有一个自己定义的nginx的配置文件，比如爱鲜蜂项目，我定义为axfnginx.conf文件</p><pre><code class="python">server {     listen       80;     server_name 39.104.176.9 localhost;     access_log /home/logs/access.log;     error_log /home/logs/error.log;     location / {         include uwsgi_params;         uwsgi_pass 127.0.0.1:8890;     }     location /static/ {         alias /home/src/axf/static/;         expires 30d;     } }</code></pre><p><b>其次</b>：修改总的nginx的配置文件，让总的nginx文件包含我们自定义的项目的axfnginx.conf文件</p><p>总的nginx配置文件在：/etc/nginx/nginx.conf中</p><p><img src="/2018/12/14/Django/Django/django_centos_nginx_peizhi.png" alt="django_centos_nginx_peizhi"></p><p>以上步骤操作完成以后，需要重启nginx：</p><pre><code class="python">systemctl restart nginx</code></pre><h4 id="4-2-配置uwsgi文件"><a href="#4-2-配置uwsgi文件" class="headerlink" title="4.2 配置uwsgi文件"></a>4.2 配置uwsgi文件</h4><p>在conf文件夹下除了包含自定义的axfnginx.conf文件，还有我们定义的uwsgi.ini文件</p><pre><code class="python">[uwsgi]projectname = axfbase = /home/src# 守护进程master = true# 进程个数processes = 4# 虚拟环境pythonhome = /home/env/axfenv# 项目地址chdir = %(base)/%(projectname)# 指定python版本pythonpath = /usr/local/python3/bin/python3# 指定uwsgi文件module = %(projectname).wsgi# 和nginx通信地址:端口socket = 127.0.0.1:8890# 日志文件地址logto = /home/logs/uwsgi.log</code></pre><p>​<br>运行项目:</p><pre><code class="python">/home/env/axfeng/bin/python3/uwsgi --ini uwsgi.ini</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django项目部署 </tag>
            
            <tag> MariaDB安装 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
